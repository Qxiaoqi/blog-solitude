---
title: 业务基础库封装设计
date: 2021-07-21 19:00:00
toc: true
categories:
- 前端
tags: 
- Infra
cover: https://iph.href.lu/500x250
---

# 业务基础库封装设计

## 背景

是针对的 pc 业务，之前的开发没什么规范，一些常用的方法基本上就是项目之间复制来复制去，导致非常的杂乱。比如说 http 请求，有的用 axios 封装的，有的用 jquery 封装的，还有的自己封装，非常的混乱。其次，项目缺乏质量监控体系，排查问题非常的麻烦，只能等用户反馈问题，然后去修，往往没办法判断出问题（S背景）。

基于这些原因，我自己搞了一套基础库来统一这些流程，最终目标是让开发过程更加的友好统一，而且能有一些线上排查问题的手段（T任务）。

基础库内封装了请求、登陆态、pc业务使用的iframe方案，因此使用postMessage通信、以及一些其他常用的公共方法封装等等。质量监控体系则包含http请求上报、逻辑错误上报、资源加载上报这些。（A行动）

最终的结果是，使用了之后（R结果）
* 开发上，很多常用的方法直接能使用，大大减少了代码冗余，很多逻辑不用自己再重复的去写，效率上能得到一个很好的提升。同时一些项目的一些公共方法得到统一，比如http请求，不再是随心所欲的去搞。
* 质量监控上，多了一种线上问题排查的手段，之前大部分都是等用户来反馈，使用这套方案能自己通过质量上报去发现一些潜在的问题，及时修复。

## 项目细节

1. 对于请求的封装：就是对xhr的封装，常用Content-Type请求头，from-data，x-www-form-urlencoded,application/json三种，需要针对这三种分别做对应的数据处理。然后就是xhr的正常请求，不过由于需要http监控上报，因此需要使用EventEmitter来处理xhr请求成功、失败、超时等几种情况，emit出来然后on监听这些状态，进而对这些做不同的上报。

2. 登陆态：常规的Cookie-Session方案，会有多台服务器Session不一致问题，可以尝试引到JWT方案上，然后详细解释JWT方案优势，HTTP无状态特点，CSRF等。

3. iframe跨域通信：目前的pc端的方案是，iframe内使用我们的页面，因为mp是两个部门的项目，内嵌我们的iframe是为了把发布等流程放到我们自己负责，而不被阻塞流程。但是也要接受iframe带来的问题，比如典型的跨域问题。一般常用postMessage来解决，当然也可一使用hashchange来解决。其实iframe更多的问题可能是体验样式上的一些问题，比如：
【高度自适应】iframe是需要指定宽高的，可以通过postMessage来传递高度。
【窗口滚动】同样需要postMessage传递到外层然后外层来跳转。
【弹窗问题】内外是不同窗口，因此很难定位到中间位置，诸如此类问题。

4. 质量监控：使用addEventListener
【未捕获reject】unhandledrejection捕获到没有处理过的reject。
【脚本错误】error捕获脚本错误和资源错误（instanceof ErrorEvent脚本错误，剩余的instanceof Error都是资源错误），开启Vue.config.errorHandler之后会没办法捕获到脚本错误
【资源错误】但是资源错误的捕获需要提前放，如果启动时资源加载错误，框架中此时还没有监听，因此没办法捕获，需要单独写一份js，然后脚手架中引入该文件

5. 对于上报的处理：上报不能一条一条的上报，需要累积达到某个阈值情况下再上报，减少请求量。同时还要考虑setInterval定期排空队列，以免没有达到阈值漏上报。然后监听页面unload卸载时也要清空队列，由于可能会在unload时期忽略xhr，因此使用sendBeacon来保证页面卸载时也能上报。

整个结构设计：一个类似事件总线，贯穿整个基础库，比如质量监控中需要上报的地方全部都会emit到这个事件总线上，然后在事件总线上统一on事件触发上报，整个结构更加清晰整洁。单例模式则主要运用在比如事件总线，只允许一条事件总线存在，因此需要单例模式来处理。

## 常见追问

### 跨域资源错误怎么处理?
1. 添加crossorigin="anonymous"
此步骤的作用是告知浏览器以匿名方式获取目标脚本。这意味着请求脚本时不会向服务端发送潜在的用户身份信息（例如 Cookies、HTTP 证书等）。

2. 添加跨域 HTTP 响应头：
Access-Control-Allow-Origin: *

### onError 和 addEventListener('error')区别？
window.onerror 不能捕获到 资源加载错误
其他的基本都相同，除了错误参数不太一样，但是都能拿到对应的JS执行错误

